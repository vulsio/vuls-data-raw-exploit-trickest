{
	"id": "CVE-2024-26654",
	"tags": [
		{
			"label": "Product",
			"message": "Linux"
		},
		{
			"label": "Version",
			"message": "198de43d758c< 9d66ae0e7bb7 "
		},
		{
			"label": "Vulnerability",
			"message": "n/a"
		}
	],
	"description": " In the Linux kernel, the following vulnerability has been resolved:ALSA: sh: aica: reorder cleanup operations to avoid UAF bugsThe dreamcastcard->timer could schedule the spu_dma_work and thespu_dma_work could also arm the dreamcastcard->timer.When the snd_pcm_substream is closing, the aica_channel will bedeallocated. But it could still be dereferenced in the workerthread. The reason is that del_timer() will return directlyregardless of whether the timer handler is running or not andthe worker could be rescheduled in the timer handler. As a result,the UAF bug will happen. The racy situation is shown below:      (Thread 1)                 |      (Thread 2)snd_aicapcm_pcm_close()          | ...                             |  run_spu_dma() //worker                                 |    mod_timer()  flush_work()                   |  del_timer()                    |  aica_period_elapsed() //timer  kfree(dreamcastcard->channel)  |    schedule_work()                                 |  run_spu_dma() //worker  ...                            |    dreamcastcard->channel-> //USEIn order to mitigate this bug and other possible corner cases,call mod_timer() conditionally in run_spu_dma(), then implementPCM sync_stop op to cancel both the timer and worker. The sync_stopop will be called from PCM core appropriately when needed.",
	"poc": {
		"githubs": [
			"https://github.com/fkie-cad/nvd-json-data-feeds"
		]
	}
}
