{
	"id": "CVE-2021-47561",
	"tags": [
		{
			"label": "Product",
			"message": "Linux"
		},
		{
			"label": "Version",
			"message": "3cfc88380413< cc432b0727ce "
		},
		{
			"label": "Vulnerability",
			"message": "n/a"
		}
	],
	"description": " In the Linux kernel, the following vulnerability has been resolved:i2c: virtio: disable timeout handlingIf a timeout is hit, it can result is incorrect data on the I2C busand/or memory corruptions in the guest since the device can still beoperating on the buffers it was given while the guest has freed them.Here is, for example, the start of a slub_debug splat which wastriggered on the next transfer after one transfer was forced to timeoutby setting a breakpoint in the backend (rust-vmm/vhost-device): BUG kmalloc-1k (Not tainted): Poison overwritten First byte 0x1 instead of 0x6b Allocated in virtio_i2c_xfer+0x65/0x35c age=350 cpu=0 pid=29 \t__kmalloc+0xc2/0x1c9 \tvirtio_i2c_xfer+0x65/0x35c \t__i2c_transfer+0x429/0x57d \ti2c_transfer+0x115/0x134 \ti2cdev_ioctl_rdwr+0x16a/0x1de \ti2cdev_ioctl+0x247/0x2ed \tvfs_ioctl+0x21/0x30 \tsys_ioctl+0xb18/0xb41 Freed in virtio_i2c_xfer+0x32e/0x35c age=244 cpu=0 pid=29 \tkfree+0x1bd/0x1cc \tvirtio_i2c_xfer+0x32e/0x35c \t__i2c_transfer+0x429/0x57d \ti2c_transfer+0x115/0x134 \ti2cdev_ioctl_rdwr+0x16a/0x1de \ti2cdev_ioctl+0x247/0x2ed \tvfs_ioctl+0x21/0x30 \tsys_ioctl+0xb18/0xb41There is no simple fix for this (the driver would have to always createbounce buffers and hold on to them until the device eventually returnsthe buffers), so just disable the timeout support for now.",
	"poc": {
		"githubs": [
			"https://github.com/fkie-cad/nvd-json-data-feeds"
		]
	}
}
